<?xml version="1.0"?>
<doc>
    <assembly>
        "WASimClient_CLI"
    </assembly>
    <members>
        <member name="F:WASimCommander.CLI.Client.WASimClient.m_client">
\}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.setLogLevel(&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;)">
See \refwccc{setLogLevel()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.logLevel(&lt;unknown type&gt;,&lt;unknown type&gt;)">
\}
\name  Logging settings
\{
See \refwccc{logLevel()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.sendCommandWithResponse(WASimCommander.CLI.Structs.Command,WASimCommander.CLI.Structs.Command@,System.Nullable`1{System.UInt32})">
See \refwccc{sendCommandWithResponse()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.sendCommand(WASimCommander.CLI.Structs.Command)">
\}
\name Low level API
\{
See \refwccc{sendCommand()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.lookup(&lt;unknown type&gt;,System.String,System.Int32@)">
See \refwccc{lookup()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.list(&lt;unknown type&gt;)">
\}
\name Metadata retrieval
\{
See \refwccc{list()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.removeCustomKeyEvent(System.UInt32)">
See \refwccc{removeCustomKeyEvent(uint32_t)}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.registerCustomKeyEvent(System.String,System.Nullable`1{System.Boolean})">
See \refwccc{registerCustomKeyEvent()}. This method overload doesn't provide the generated event ID as a return value.
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.registerCustomKeyEvent(System.String,System.UInt32@,System.Nullable`1{System.Boolean})">
See \refwccc{registerCustomKeyEvent()};
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.sendKeyEvent(System.UInt32,System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32})">
\}
\name Simulator Key Events
\{
See \refwccc{sendKeyEvent(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) const}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.registerEvent(WASimCommander.CLI.Structs.RegisteredEvent)">
\}
\name RPN calculator code execution and reusable events
\{
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.saveDataRequest(WASimCommander.CLI.Structs.DataRequest)">
\}
\name Data change subscriptions (variables and calculated results)
\{
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.setOrCreateLocalVariable(System.String,System.String,System.Double!System.Runtime.CompilerServices.IsConst)">
See \refwccc{setOrCreateLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.setOrCreateLocalVariable(System.String,System.Double!System.Runtime.CompilerServices.IsConst)">
See \refwccc{setOrCreateLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.setLocalVariable(System.String,System.Double!System.Runtime.CompilerServices.IsConst)">
See \refwccc{setLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getOrCreateLocalVariable(System.String,System.String,System.Double,System.Double@)">
\sa \refwccc{getOrCreateLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getOrCreateLocalVariable(System.String,System.Double,System.Double@)">
\sa \refwccc{getOrCreateLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getLocalVariable(System.String,System.String,System.Double@)">
See \refwccc{getLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getLocalVariable(System.String,System.Double@)">
See \refwccc{getLocalVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getVariable(WASimCommander.CLI.Structs.VariableRequest,System.Double@,System.String@)">
            <summary> Get the value of a variable with _either_ a numeric or string result based on the unit type of the requested variable. </summary>
The request is executed as calculator code since that is the only way to get string results. Unlike `executeCalculatorCode()`, this method will not return a string representation of a numeric value.
Note that only some 'A', 'C', and 'T' type variables can have a string value type in the first place. \sa \refwccc{getVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getVariable(WASimCommander.CLI.Structs.VariableRequest,System.String@)">
            <summary> Get the value of a variable with a string result type. The request is executed as calculator code since that is the only way to get string results. </summary>
Note that only some 'A', 'C', and 'T' type variables can have a string value type in the first place. \sa \refwccc{getVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.getVariable(WASimCommander.CLI.Structs.VariableRequest,System.Double@)">
\}
\name Variables accessor methods
\{
<summary> Get the value of a variable with a numeric result type. This is the most typical use case since most variable types are numeric. </summary> \sa \refwccc{getVariable()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.executeCalculatorCode(System.String,&lt;unknown type&gt;,System.Double@,System.String@)">
            <summary> Execute calculator code with both numeric and string results. </summary>  \sa \refwccc{executeCalculatorCode()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.executeCalculatorCode(System.String,&lt;unknown type&gt;,System.String@)">
            <summary> Execute calculator code with a string result type. </summary> \sa \refwccc{executeCalculatorCode()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.executeCalculatorCode(System.String,&lt;unknown type&gt;,System.Double@)">
            <summary> Execute calculator code with a numeric result type. </summary>  \sa \refwccc{executeCalculatorCode()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.executeCalculatorCode(System.String)">
\}
\name RPN calculator code execution and reusable events
\{
<summary> Execute calculator code without result </summary> \sa \refwccc{executeCalculatorCode()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.connectServer(System.Nullable`1{System.UInt32})">
See \refwccc{connectServer()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.pingServer(System.Nullable`1{System.UInt32})">
See \refwccc{pingServer()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.disconnectSimulator">
See \refwccc{disconnectSimulator()}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.connectSimulator(System.Int32,System.Nullable`1{System.UInt32})">
            <summary> Connect to the Simulator engine using a specific network configuration ID from a SimConnect.cfg file. The file must be in the same folder as the executable running the Client. </summary>
            <paramref name="networkConfigId"> network configuration ID from a SimConnect.cfg file. The file must be in the same folder as the executable running the Client. </paramref>\n
<paramref name="timeout"> (optional) Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value. </paramref>
\return See \refwccc{connectSimulator(int,uint32_t)}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.connectSimulator(System.Nullable`1{System.UInt32})">
            <summary> Connect to the Simulator engine on a local connection. </summary>
            <paramref name="timeout"> (optional) Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value. </paramref>
\return See \refwccc{connectSimulator(uint32_t)}
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.serverVersion">
            <summary> Returns version number of the WASimModule server, if known. The version is populated after a successful Ping command or server connection. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.clientVersion">
            <summary> Returns version number of the WASimClient. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.isConnected">
            <summary> Returns true if connected to WASimModule server. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.isInitialized">
            <summary> Returns true if connected to the Simulator (SimConnect). </summary>
        </member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.status">
\name Network actions, status, and settings
\{
<summary> Get current connection status of this client. \sa WASimCommander::Client::ClientStatus </summary></member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.#ctor(System.UInt32,System.String)">
            <summary> Construct a new client with the given ID and with initial settings read from the file specified in `configFile` (.ini format, see default file for example). </summary>
The client ID must be unique among any other possible clients and cannot be zero. See \refwccc{WASimClient()} for more details.
</member>
        <member name="M:WASimCommander.CLI.Client.WASimClient.#ctor(System.UInt32)">
            <summary> Construct a new client with the given ID. The ID must be unique among any other possible clients and cannot be zero. </summary>
See \refwccc{WASimClient()} for more details.
</member>
        <member name="E:WASimCommander.CLI.Client.WASimClient.OnResponseReceived">
            <summary>This event is triggered whenever _any_ Command is received from the server. This is typically `Ack` or `Nak` responses but may also include things list results, pings, or disconnection notices.</summary>
        </member>
        <member name="E:WASimCommander.CLI.Client.WASimClient.OnCommandResult">
            <summary> This event is triggered whenever any response to a Command is returned from the Server. Responses are Command objects of `Ack` or `Nak` type. </summary>
        </member>
        <member name="E:WASimCommander.CLI.Client.WASimClient.OnLogRecordReceived">
            <summary>Log records delivered from Client and/or Server. </summary>
        </member>
        <member name="E:WASimCommander.CLI.Client.WASimClient.OnDataReceived">
            <summary> Delivers data value subscription updates as they arrive from the Server. </summary>
        </member>
        <member name="E:WASimCommander.CLI.Client.WASimClient.OnListResults">
            <summary> Delivers list results after a successful `WASimClient.list()` command. </summary>
        </member>
        <member name="E:WASimCommander.CLI.Client.WASimClient.OnClientEvent">
\}
<summary> WASimClient events like connection and disconnection. </summary></member>
        <member name="T:WASimCommander.CLI.Client.WASimClient.ClientEventDelegate">
\name Event handler delegate types
\{
</member>
        <member name="T:WASimCommander.CLI.Client.WASimClient">
C+/CLI wrapper implementation of `WASimCommander::Client::WASimClient`.
See documentation for the C++ class for most of the details. Only implementation differences are documented here.

This is pretty much a method-for-method version of the C++ version, with parameter types adjusted accordingly,
and using the CLI versions of relevant data structures and enum types.

The main difference is that callbacks from the C++ version are delivered here as managed Events, with defined delegate types to handle them.
And unlike the callback system, the events can have multiple subscribers if needed.

\note Events are delivered asyncronously from a separtely running thread. The event handlers should be reentrant since they could be callled at any time. \n
Typically, interactions with GUI components will not be possible directly from inside the event handlers -- use a `Dispatcher` to marshal GUI interactions
back to the main thread.
</member>
        <member name="T:WASimCommander.CLI.ValueTypes">
            <summary> Predefined value types </summary>
Using these constants for the `WASimCommander::CLI::Structs::DataRequest::valueSize` property will allow delta epsilon comparisons.
</member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.Int32)">
            <summary> Construct a variable request a Local variable ('L') with the specified numeric ID. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.String,System.Boolean,System.String)">
            <summary> Construct a variable request for a Local ('L') variable with the specified name. </summary>
`createVariable` will create the L var on the simulator if it doesn't exist yet (for "Get" as well as "Set" commands). An unit name can also be provided with this overload.
</member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.String,System.Boolean)">
            <summary> Construct a variable request for a Local ('L') variable with the specified name. </summary>
`createVariable` will create the L var on the simulator if it doesn't exist yet (for "Get" as well as "Set" commands). An optional unit name can also be provided.
</member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.String)">
            <summary> Construct a variable request a Local variable ('L') with the specified name. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.Int32,System.Int32,System.Byte)">
            <summary> Construct a variable request for a Simulator variable ('A') with given variable ID, numeric unit specifier, and index (use zero for non-indexed variables). </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.String,System.String,System.Byte)">
            <summary> Construct a variable request for a Simulator variable ('A') with given name, named unit specifier, and index (use zero for non-indexed variables). </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.Char,System.Int32,System.Int32)">
            <summary> Construct a variable request for specified variable type ('A', 'L', etc),  numeric variable ID, and with a numeric unit ID specifier. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.Char,System.String,System.String)">
            <summary> Construct a variable request for specified variable type ('A', 'L', etc), variable name, and with a named unit specifier. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.Char,System.Int32)">
            <summary> Construct a variable request for specified variable type ('A', 'L', etc) and numeric variable ID. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.VariableRequest.#ctor(System.Char,System.String)">
            <summary> Construct a variable request for specified variable type ('A', 'L', etc) and variable name. </summary>
        </member>
        <member name="T:WASimCommander.CLI.Structs.VariableRequest">
            <summary> Structure for using with `WASimClient::getVariable()` and `WASimClient::setVariable()` to specify information about the variable to set or get. Variables and Units can be specified by name or by numeric ID. </summary>
Only some variable types have an associated numeric ID ('A', 'L', 'T' types) and only some variable types accept a Unit specifier ('A', 'C', 'E', 'L' types). Using numeric IDs, if already known, is more efficient
on the server side since it saves the lookup step.
For full documentation of each field see `WASimCommander::Client::VariableRequest`.
</member>
        <member name="T:WASimCommander.CLI.Structs.RegisteredEvent">
            <summary> Structure to hold data for registered (reusable) calculator events. Used to submit events with `WASimClient::registerEvent()`. </summary>
For full documentation of each field see `WASimCommander::Client::RegisteredEvent`.
</member>
        <member name="T:WASimCommander.CLI.Structs.ListResult">
            <summary> Structure for delivering list results, eg. of local variables sent from Server. </summary>
For full documentation of each field see `WASimCommander::Client::ListResult`.
</member>
        <member name="T:WASimCommander.CLI.Structs.ClientEvent">
            <summary> Client Event data, delivered via callback. </summary>
For full documentation of each field see `WASimCommander::Client::ClientEvent`.
</member>
        <member name="M:WASimCommander.CLI.Structs.DataRequestRecord.ToString">
\}
<summary>Serializes this `DataRequestRecord` to string for debugging purposes.</summary>
To return the request's _value_ as a string, see `tryConvert()` or the `String ^()` operator. \sa DataRequest::ToString()
</member>
        <member name="M:WASimCommander.CLI.Structs.DataRequestRecord.op_Implicit(WASimCommander.CLI.Structs.DataRequestRecord)~System.Double">
\name Implicit conversion operators for various types.
\{
</member>
        <member name="M:WASimCommander.CLI.Structs.DataRequestRecord.tryConvert(System.String@)">
            <summary> Overload for String type results. This will simply load whatever bytes are in the `data` array into a String, and only
returns `false` (and an empty String) if the data array is empty or starts with a null character byte (`0x00`). </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequestRecord.tryConvert``1(``0@)">
            <summary> Tries to populate a value reference of the desired type `T` and returns true or false
depending on if the conversion was valid (meaning the size of requested type matches the data size). </summary>
If the conversion fails, result is default-initialized.
The requested type (`T`) must be a `value` type (not reference) and be default-constructible, (eg. numerics, chars), or fixed-size arrays of such types.
</member>
        <member name="T:WASimCommander.CLI.Structs.DataRequestRecord">
            <summary> `DataRequestRecord` inherits and extends `WASimCommander::CLI::Structs::DataRequest` with data pertinent for use by a data consumer/Client.
In particular, any value data sent from the server is stored here as a byte array in the `data` member (a byte array). </summary>

`DataRequest` subscription results are delivered by `WASimClient` (via `OnDataReceived` event) using this `DataRequestRecord` structure.
WASimClient also holds a list of all data requests which have been added using `WASimClient::saveDataRequest()` method. These
requests are available for reference using `WASimClient::dataRequest()`, `WASimClient::dataRequests()`, and `WASimClient::dataRequestIdsList()` methods.
For full documentation of each field see `WASimCommander::Client::DataRequestRecord`.

For assistance with converting the raw data to actual values, there are a couple `bool tryConvert(T)` templates which try to populate a value reference
(`out` parameter) of the desired type and returns true or false depending on if the conversion was valid. Validity is based only on the data array size vs.
the requested type size, so it will happily populate an Int32 with data representing a float value, since the type sizes match. **The user must know what data
type they are expecting.**

One version of `tryConvert()` handles basic numeric types, and another is a special overload for returning Strings.

There are also implicit conversion operators for all numeric types and String. If conversion fails, these return a default-constructed instance,
typically zero or an empty string.

Also note that the size of the data array may or _may not_ be the same as the inherited `DataRequest::valueSize` member, since that may contain
special values for preset types. Always check the actual data array size (`data.Length`) if you need to know the storage requirements.
</member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.ToString">
            <summary>Serializes this `DataRequest` to a string for debugging purposes.</summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.setUnitName(System.String)">
            <summary>Set the `unitName` member using a `string` type value. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.setNameOrCode(System.String)">
            <summary>Set the `nameOrCode` member using a `string` type value. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,&lt;unknown type&gt;,System.String,&lt;unknown type&gt;,System.UInt32,System.Single)">
            <summary> Constructs a calculator code request (`requestType = RequestType::Calculated`) with given update period, interval, and epsilon values.. </summary>
This overload, w/out a `valueSize` argument automatically determines the size based on the `resultType` argument:
- `CalcResultType::Double`  = `WASimCommander::DATA_TYPE_DOUBLE`
- `CalcResultType::Integer` = `WASimCommander::DATA_TYPE_INT32`
- `CalcResultType::String`  = 256
</member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,&lt;unknown type&gt;,System.String)">
            <summary> Constructs a calculator code request (`requestType = RequestType::Calculated`) with default update period on every `UpdatePeriod.Tick`. </summary>
This overload, w/out a `valueSize` argument automatically determines the size based on the `resultType` argument:
- `CalcResultType::Double`  = `WASimCommander::DATA_TYPE_DOUBLE`
- `CalcResultType::Integer` = `WASimCommander::DATA_TYPE_INT32`
- `CalcResultType::String`  = 256
</member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,&lt;unknown type&gt;,System.String,System.UInt32,&lt;unknown type&gt;,System.UInt32,System.Single)">
            <summary> Constructs a calculator code request (`requestType = RequestType::Calculated`) with given update period, interval, and epsilon values.. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,&lt;unknown type&gt;,System.String,System.UInt32)">
            <summary> Constructs a calculator code request (`requestType = RequestType::Calculated`) with default update period on every `UpdatePeriod.Tick`. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,System.String,System.String,System.Byte,System.UInt32,&lt;unknown type&gt;,System.UInt32,System.Single)">
            <summary> Constructs a request for a named Simulator Variable (`requestType = RequestType::Named` and `varTypePrefix = 'A'`) with given update period, interval, and epsilon values. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,System.String,System.String,System.Byte,System.UInt32)">
            <summary> Constructs a request for a named Simulator Variable (`requestType = RequestType::Named` and `varTypePrefix = 'A'`) with default update period on every `UpdatePeriod.Tick`. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,System.Char,System.String,System.UInt32,&lt;unknown type&gt;,System.UInt32,System.Single)">
            <summary> Constructs a request for a named variable (`requestType = RequestType::Named`) with given update period, interval, and epsilon values. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor(System.UInt32,System.Char,System.String,System.UInt32)">
            <summary> Constructs a request for a named variable (`requestType = RequestType::Named`) with default update period on every `UpdatePeriod.Tick`. </summary>
        </member>
        <member name="M:WASimCommander.CLI.Structs.DataRequest.#ctor">
            <summary> Default constructor. Properties must be set to valid values, either later or inline, eg. `new DataRequest() { requestId: 1, requestType: RequestType::Named, ...}`. </summary>
        </member>
        <member name="T:WASimCommander.CLI.Structs.DataRequest">
            <summary> Structure for value update subscription requests. \sa WASimCommander:CommandId::Subscribe command. </summary>
For full documentation of each field see `WASimCommander::DataRequest`.
</member>
        <member name="T:WASimCommander.CLI.Structs.LogRecord">
            <summary> Log record structure. \sa WASimCommander:CommandId::Log command. </summary>
For full documentation of each field see `WASimCommander::LogRecord`.
</member>
        <member name="T:WASimCommander.CLI.Structs.Command">
            <summary> Command data structure. The member contents depend on the command type as described in each command type of the `CommandId` enum documentation. \sa CommandId enum </summary>
For full documentation of each field see `WASimCommander::Command`.
</member>
        <member name="T:WASimCommander.CLI.Enums.HR">
            <summary> Method return status values; HRESULT "alias" </summary>
        </member>
        <member name="T:WASimCommander.Client.WASimClient.Private">
\}
</member>
        <member name="M:WASimCommander.Client.WASimClient.setLogLevel(&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;)">
Set the current minimum logging severity level for the specified `facility` and `source` to `level`. \sa logLevel(), setLogCallback(), \refwce{CommandId::Log}
\param level The new minimum level. One of `WASimCommander::LogLevel` enum values. Use `LogLevel::None` to disable logging on the given facility/source.
\param facility One or more of `WASimCommander::LogFacility` enum flags. The `LogFacility::Remote` facility is the one delivered via the log callback handler.
\param source One of \refwcc{LogSource} enum values.
</member>
        <member name="M:WASimCommander.Client.WASimClient.logLevel(&lt;unknown type&gt;,&lt;unknown type&gt;)">
\}
\name  Logging settings
\{
Get the current minimum logging severity level for the specified `facility` and `source`.  \sa setLogLevel(), setLogCallback(), \refwce{CommandId::Log}
\param facility **One** of `WASimCommander::LogFacility` enum flag values. This must be only one of the available flags, not a combination.  The `Remote` facility is the one delivered via the log callback handler.
\param source One of \refwcc{LogSource} enum values.
\return The current `WASimCommander::LogLevel` value, or `LogLevel::None` if the parameters were ivalid or the actual level is unknown (see Note below).
\note The remote server logging level for `File` and `Console` facilities is unknown at Client startup. The returned values are only going to be correct if they were set by this instance of the Client (using `setLogLevel()`).
</member>
        <member name="M:WASimCommander.Client.WASimClient.sendCommandWithResponse(WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,WASimCommander.Command*,System.UInt32)">
Sends a command, in the form of a `WASimCommander::Command` structure, to the server for processing and waits for a reply (an `Ack/Nak` response `Command`).
The various command types and the data requirements for each are described in the `WASimCommander::Enums::CommandId` documentation.
\param command The `Command` struct defining the command and associated data to send.
\param response Pointer to an initialised `Command` structure for storing the resulting response (a Command with a `commandId` of `Ack` or `Nak`), if any.
\param timeout The maximum time to wait for a response, in milliseconds. If `0` (default) then the default network timeout value is used (`defaultTimeout()`, `setDefaultTimeout()`).
\return `S_OK` on success, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or possibly `E_FAIL` on unknown error (check log for details).
</member>
        <member name="M:WASimCommander.Client.WASimClient.sendCommand(WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\}
\name Low level API
\{
Sends a command, in the form of a `WASimCommander::Command` structure, to the server for processing. The various command types and the data requirements for each are described in the `WASimCommander::Enums::CommandId` documentation.
To receive command responses from the server, set a callback with `setCommandResultCallback()`, then check the results for a `Command::token` which matches the `token` set in the command you're sending here.
\return `S_OK` on success, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure.
</member>
        <member name="M:WASimCommander.Client.WASimClient.lookup(&lt;unknown type&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*)">
Request a lookup of a named item to find its corresponding numeric ID. \n
Most lookup types are done on the server side, so an active connection is required. The exception is looking up Key Event IDs (\refwce{LookupItemType::KeyEventId}), which are performed locally.
\param itemType The type of item to look up. A type of variable or a measurement unit. See the \refwce{LookupItemType} documentation for details.
\param itemName The name of the thing to check for.
\param piResult Pointer to 32-bit signed integer variable to hold the result.
\return `S_OK` on success, `E_FAIL` if server returns a Nak response (typically means the item name wasn't found), `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure.
\note Except for Key Event ID type lookups, this method blocks until either the Server responds or the timeout has expired. \sa defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.list(&lt;unknown type&gt;)">
\}
\name Metadata retrieval
\{
Send a request for a list update to the server. The results are delivered using the callback set in `setListResultsCallback()`.
\param itemsType The type of thing to list. Supported types are local variables (`Enums::LookupItemType::LocalVariable`, default), subscribed Data Requests (`Enums::LookupItemType::DataRequest`), and Registered Events (`Enums::LookupItemType::RegisteredEvent`).
\return  `S_OK` on success, `E_INVALIDARG` if the item type is not supported, `E_NOT_CONNECTED` if not connected to server.
\note The list result callback is invoked from a new thread which delivers the results (\refwcc{ListResult} structure). Also check the `ListResult::result` HRESULT return code to be sure the list command completed successfully
(which may be `S_OK`, `E_FAIL` if server returned `Nak`, or `E_TIMEOUT` if the list request did not complete (results may be empty or partial)).
\sa \refwce{CommandId::List}
</member>
        <member name="M:WASimCommander.Client.WASimClient.removeCustomKeyEvent(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Remove a Custom Event previously registered with `registerCustomEvent()` method using the event's name.
This will prevent the custom event from being mapped _next_ time the client connects to SimConnect.
\note SimConnect provides no way to remove a registered Custom event. Any active SimConnect mapping will remain in effect until SimConnect is disconnected (and can still be invoked with the corresponding ID, but not by name).
\param customEventName full name of the previously registered event. Must be the same name as used with `registerCustomKeyEvent()`.
\return `S_OK` on success, `E_INVALIDARG` if the eventId wasn't found.
\since v1.3.0
</member>
        <member name="M:WASimCommander.Client.WASimClient.registerCustomKeyEvent(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*,System.Boolean)">
Register a "Custom Simulator [Key] Event" by providing an event name. The method optionally returns the generated event ID, which can later be used with `sendKeyEvent()` method instead of the event name.
It can also be used to look up a previous registration's ID if the event name has already been registered. \n\n
Custom event names are mapped to internally-generated unique IDs using a standard SimConnect call to
[MapClientEventToSimEvent](https://docs.flightsimulator.com/html/Programming_Tools/SimConnect/API_Reference/Events_And_Data/SimConnect_MapClientEventToSimEvent.htm#parameters),
and the documentation briefly describes custom event usage and name syntax in the `EventName` parameter description. This method serves a similar purpose (and in fact eventually calls that same SimConnect function). \n\n
The mappings must be re-established every time a new connection with SimConnect is made, which WASimClient takes care of automatically. If currently connected to the simulator, the event is immediately mapped,
otherwise it will be mapped upon the next connection. An event registration can be removed with `removeCustomKeyEvent()` which will prevent any SimConnect mapping from being created upon the _next_ connection. \n\n
If you're not going to store the ID that will be generated anyway, `sendKeyEvent(customEventName, ...)` can be used directly, which will automatically call this method the first time the event name is used.
The ID can always be looked up later if needed (by calling this method). \n\n
Note that the custom event mapping/triggering feature is actually just a convenience for the WASimClient user and doesn't involve the usual server interactions (WASimModule) at all.
\param customEventName Name of the Event to register. The event name _must_ contain a "." (period) or start with a "#", otherwise an `E_INVALIDARG` result is returned. \n
  If an event with the same name has already been registered, the method returns `S_OK` and no further actions are performed (besides setting the optional `puiCustomEventId` pointer value, see below).
\param puiCustomEventId Optional pointer to 32-bit unsigned integer variable to return the generated event ID. This ID can be used to trigger the event later using `sendKeyEvent()` (which is more efficient than using the event name each time).
  The ID will always be unique per given event name, and is always equal to or greater than the `Client::CUSTOM_KEY_EVENT_ID_MIN` constant value. \n
  The pointer's value will be populated even if the event name was already registered (with the result of the previously generated ID).
\param useLegacyTransmit Optional, default `false`. Boolean value indicating that the deprecated `SimConnect_TransmitClientEvent()` function should be used to trigger the event instead of the newer `SimConnect_TransmitClientEvent_EX1()`.
  This may be necessary to support models which haven't updated to the newer version of the event handler. Note that the old `TransmitClientEvent()` function only supports sending 1 event value (vs. 5 for the "_EX1" version). \n
  To re-register the same event name but with a different value for `useLegacyTransmit` parameter, first remove the initial registration with `removeCustomKeyEvent()` and then call this method again.
\return `S_OK` on success, `E_INVALIDARG` if the event name is invalid.
\since v1.3.0
</member>
        <member name="M:WASimCommander.Client.WASimClient.sendKeyEvent(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
This is an overloaded method. See `sendKeyEvent(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) const` for main details.
This version allows triggering Key Events by name instead of an ID. \n\n
All simulator event names must be resolved, or mapped, to a numeric ID before they can be triggered (used).
The first time this method is invoked with a particular event name, it tries to associate that name with an ID (based on the event name, as described below).
If successful, the ID is cached, so subsequent calls to this method, with the same event name, will use the cached ID instead of trying to resolve the name again.
- For _standard_ Key Events, the name is resolved to an ID using the 'lookup()' method and the resulting ID (if valid) is cached for future uses. There **must** be an active server connection for this to work.
- For _custom_ events (names that contain a "." (period) or start with a "#"), the event is first registered using `registerCustomKeyEvent()` and the resulting ID is cached if that succeeds.

\param keyEventName Name of the Event to trigger.
\param v1,v2,v3,v4,v5 Optional values to pass to the event handler. Defaults are all zeros.
\return `S_OK` on success, `E_INVALIDARG` if event name could not be resolved to an ID, `E_NOT_CONNECTED` if not connected (server or sim, depending on event type),
`E_TIMEOUT` on server communication failure, or `E_FAIL` on unexpected SimConnect error.
\note The name-to-ID cache is kept as a simple `std::unordered_map` type, so if you have a better way to save the event IDs from `lookup()` or `registerCustomKeyEvent()`,
use that instead, and call the more efficient `sendKeyEvent(eventId, ...)` overload directly.
\since v1.3.0 - Added ability to trigger custom named events.
</member>
        <member name="M:WASimCommander.Client.WASimClient.sendKeyEvent(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
\}
\name Simulator Key Events
\{
Can be used to trigger standard Simulator "Key Events" as well as "custom" _Gauge API/SimConnect_ events. Up to 5 optional values can be passed onto the event handler.
This provides functionality similar to the _Gauge API_ function `trigger_key_event_EX1()` and `SimConnect_TransmitClientEvent[_EX1()]`.  \n\n
*Standard* Key Event IDs can be found in the SimConnect SDK header file 'MSFS/Legacy/gauges.h' in the form of `KEY_*` macro values, and event names can also be
resolved to IDs programmatically using the `lookup()` method. No preliminary setup is required to trigger these events, but a full connection to WASimModule ("server") is needed.
These are triggered on the simulator side using `trigger_key_event_EX1()` function calls. \n\n
*Custom Events* for which a numeric ID is already known (typically in the _Gauge API_ `THIRD_PARTY_EVENT_ID_MIN`/`THIRD_PARTY_EVENT_ID_MAX` ID range)
can also be triggered directly as with standard events. These types of events are also passed directly to `trigger_key_event_EX1()`. \n\n
*Named Custom Events*, for which an ID is not known or predefined, **must** first be registered with `registerCustomKeyEvent()`, which creates and maps (and optionally returns)
a unique ID corresponding to the custom event name. An active simulator (SimConnect) connection is required to trigger these types of events.
They are invoked via `SimConnect_TransmitClientEvent[_EX1()]` method directly from this client (this is actually just a convenience for the WASimClient user to avoid needing a separate SimConnect session).
Which actual SimConnect function is used depends on how the custom event was registered (default is to use the newer "_EX1" version which allows up to 5 event values). \n
See docs for `registerCustomKeyEvent()` for further details on using custom simulator events.
\param keyEventId Numeric ID of the Event to trigger.
\param v1,v2,v3,v4,v5 Optional values to pass to the event handler. Defaults are all zeros.
\return `S_OK` on success, `E_NOT_CONNECTED` if not connected (server or sim, see above), `E_TIMEOUT` on server communication failure, or `E_FAIL` on unexpected SimConnect error.
\note For Key Events triggered via `trigger_key_event_EX1()`, Server responds asynchronously with an Ack/Nak response to \refwce{CommandId::SendKey} command type;
  A 'Nak' means the event ID is clearly not valid (eg. zero), but otherwise the simulator provides no feedback about event execution
  (from [their docs](https://docs.flightsimulator.com/html/Programming_Tools/WASM/Gauge_API/trigger_key_event_EX1.htm#return_values): "If the event requested is not appropriate, it will simply not happen."). \n\n
  For _custom named_ events, triggered via `SimConnect_TransmitClientEvent[_EX1()]`, SimConnect may asynchronously send EXCEPTION type response messages if the ID isn't valid
  (likely because the event hasn't been successfully registered with `registerCustomKeyEvent()`). These messages are passed through to WASimClient's logging facilities at the `Warning` level.
  But again there is no actual confirmation that the event is going to do anything.
\since v1.3.0 - Added ability to trigger custom named events.
</member>
        <member name="M:WASimCommander.Client.WASimClient.registeredEvents">
Returns a list of all registered events which have been added to the Client with `registerEvent()`. The list members are created by copy.
</member>
        <member name="M:WASimCommander.Client.WASimClient.registeredEvent(System.UInt32)">
Returns a copy of a `RegisteredEvent` which has been previously added with `registerEvent()`. If the event with the given `eventId` doesn't exist, an invalid `RegisteredEvent` is returned which has
the members `RegisteredEvent::eventId` set to `-1`, and `RegisteredEvent::code` and `RegisteredEvent::name` both empty.
</member>
        <member name="M:WASimCommander.Client.WASimClient.transmitEvent(System.UInt32)">
Trigger an event previously registered with `registerEvent()`. This is a more direct alternative to triggering events by name via SimConnect.
\param eventId ID of the previously registered event. If the event hasn't been registered, the server will log a warning but otherwise nothing will happen.
\return `S_OK` on success, `E_FAIL` on general failure (unlikely), `E_NOT_CONNECTED` if not connected to server.
\sa \refwce{CommandId::Transmit}, registerEvent(), removeEvent()
</member>
        <member name="M:WASimCommander.Client.WASimClient.removeEvent(System.UInt32)">
Remove an event previously registered with `registerEvent()` method. This is effectively the same as calling `registerEvent()` with an empty `code` parameter.
If the server is not currently connected, the removal request will be queued and sent next time a connection is established.
\param eventId ID of the previously registered event.
\return `S_OK` on success, `E_INVALIDARG` if the eventId wasn't found.
\sa \refwce{CommandId::Register}, registerEvent(), transmitEvent()
</member>
        <member name="M:WASimCommander.Client.WASimClient.registerEvent(WASimCommander.Client.RegisteredEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\}
\name RPN calculator code execution and reusable events
\{
Register a reusable event which executes a pre-set RPN calculator code string. The code is pre-compiled and stored on the server for quicker execution.
The event can have an optional custom name for direct use with any SimConnect client. Registered events can also be triggered by using the `transmitEvent()` method.
If the server is not currently connected, the event registration will be queued and sent next time a connection is established.
\return `S_OK` on success, `E_INVALIDARG` if the resulting code string is too long or if trying to change the name of an already registered event.
\sa RegisteredEvent, \refwce{CommandId::Register}, removeEvent(), transmitEvent()
</member>
        <member name="M:WASimCommander.Client.WASimClient.setDataRequestsPaused(System.Boolean)">
Enables or disables all data request subscription updates at the same time. Use this to temporarily suspend value update checks when they are not needed, but may be again in the future.
This is a lot more efficient than disconnecting and re-connecting to the server, since all the data requests need to be re-created upon every new connection (similar to SimConnect itself).
\since{v1.2}
This method can be called while not connected to the server. In this case the setting is saved and sent to the server upon next connection, before sending any data request subscriptions.
This way updates could be suspended upon initial connection, then re-enabled when the data is actually needed.
\return `S_OK` on success; If currently connected to the server, may also return `E_TIMEOUT` on general server communication failure.
</member>
        <member name="M:WASimCommander.Client.WASimClient.dataRequestIdsList">
Returns a list of all `DataRequest::requestId`s which have been added to the Client so far.
</member>
        <member name="M:WASimCommander.Client.WASimClient.dataRequests">
Returns a list of all data requests which have been added to the Client so far. (These are returned by copy operation, so for a long list it may get "expensive.")
</member>
        <member name="M:WASimCommander.Client.WASimClient.dataRequest(System.UInt32)">
Returns a copy of a `DataRequestRecord` which has been previously added. If the request with the given `requestId` doesn't exist, an invalid `DataRequestRecord` is returned which has
the members `DataRequest::requestId` set to `-1`, `DataRequest::valueSize` set to `0`, and `DataRequest::requestType` set to `RequestType::None`.
</member>
        <member name="M:WASimCommander.Client.WASimClient.updateDataRequest(System.UInt32)">
Trigger a data update on a previously-added `DataRequest`. Designed to refresh data on subscriptions with update periods of `UpdatePeriod::Never` or `UpdatePeriod::Once`, though it can be used with any subscription.
Using this update method also skips any equality checks on the server side (though any delta epsilon value remains in effect on client side).
\param requestId The ID of a previously added `DataRequest`.
\return `S_OK` on success, `E_FAIL` if the original request wasn't found,.
\sa \refwce{CommandId::Update}, saveDataRequest(), removeDataRequest()
</member>
        <member name="M:WASimCommander.Client.WASimClient.removeDataRequest(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Remove a previously-added `DataRequest`. This clears the subscription and any tracking/meta data from both server and client sides.
Using this method is effectively the same as calling `dataRequest()` with a `DataRequest` of type `RequestType::None`.
\param requestId ID of the request to remove.
\return `S_OK` on success, `E_FAIL` if the original request wasn't found.
\note If the subscription data may be needed again in the future, it would be more efficient to edit the request (using `saveDataRequest()`) and suspend updates by setting the `DataRequest::period` to `UpdatePeriod::Never`.
To resume updates change the period again.
\sa \refwc{DataRequest}, \refwce{CommandId::Subscribe}, saveDataRequest(), updateDataRequest()
</member>
        <member name="M:WASimCommander.Client.WASimClient.saveDataRequest(WASimCommander.DataRequest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
\}
\name Data change subscriptions (variables and calculated results)
\{
Add a new `WASimCommander::DataRequest` for a variable or calculated result, or update an existing data request with the same `DataRequest::requestId`.
Data changes (updates) are delivered asynchronously via the callback function set with `setDataCallback()`, which then passes a `DataRequestRecord` structure as the callback argument
(this provides both a reference to the original `DataRequest` registered here, as well as result data).
\param request The `WASimCommander::DataRequest` structure to process. See `WASimCommander::DataRequest` documentation for details of the structure members.
\param async Set to `false` (default) to wait for an `Ack`/`Nak` response from the server before returning from this method, or `true` to return without waiting for a response. See return values and the Note below for more details.
\return `S_OK` on success, `E_INVALIDARG` if there is a problem with the `DataRequest` contents. \n
If currently connected to the server and `async` is `false`, may also return `E_FAIL` if the server returned `Nak` response, or `E_TIMEOUT` on general server communication failure.
\note If currently connected to the server and the `async` param is `false`, this method will block until either the Server responds or the timeout has expired (see `defaultTimeout()`).
If the client is _not_ currently connected to the server, the request is queued until the next connection is established (and this method is non-blocking regardless of `async` argument).
\par Tracking async calls
To track the status of an async request, set a callback function with `setCommandResultCallback()`. The server should respond with an \refwce{CommandId::Ack} or \refwce{CommandId::Nak}
\refwc{Command} where the `uData` value is \refwce{CommandId::Subscribe} and the \refwc{Command::token} will be the `requestId` value from the given `request` struct.
\sa  \refwc{DataRequest} \refwce{CommandId::Subscribe}, removeDataRequest(), updateDataRequest(), setDataCallback(), DataRequestRecord
</member>
        <member name="M:WASimCommander.Client.WASimClient.setSimVarVariable(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double">
Sets a numeric value on an indexed 'A' (aka "SimVar" / "Simulator Variable") type variable. \n
This is a convenience version of `setVariable()`, equivalent to `setVariable(VariableRequest(variableName, unitName, index), value)`. See `setVariable()` and `VariableRequest` for details.
\since v1.3.0
</member>
        <member name="M:WASimCommander.Client.WASimClient.setOrCreateLocalVariable(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.Compil">
Set a Local Variable value by variable name, creating it first if it does not already exist. This first calls the `register_named_variable()` _Gauge API_ function to get the ID from the name,
which creates the variable if it doesn't exist. The returned ID (new or existing) is then used to set the value. Use the `lookup()` method to check for the existence of a variable name.
Equivalent to `setVariable(VariableRequest(variableName, true, unitName), value)`. See `setVariable()` and `VariableRequest` for details.
\param variableName Name of the local variable.
\param value The value to set. Becomes the initial value if the variable is created.
\param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic "number" type.
\return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, or `E_FAIL` on general failure (unlikely).
\sa \refwce{CommandId::SetCreate}
</member>
        <member name="M:WASimCommander.Client.WASimClient.setLocalVariable(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServic">
A convenience version of `setVariable()` for Local variable types. Equivalent to `setVariable(VariableRequest(variableName, false, unitName), value)`. See `setVariable()` and `VariableRequest` for details.
\param variableName Name of the local variable.
\param value The value to set.
\param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic "number" type.
\return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, or `E_FAIL` on general failure (unlikely).
\sa \refwce{CommandId::Set}
</member>
        <member name="M:WASimCommander.Client.WASimClient.setVariable(WASimCommander.Client.VariableRequest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is an overloaded method. This version allows setting an 'A' type (SimVar) variable to a string value. **Only 'A' type variables can be set this way.** \n
Since there is actually no direct way to set string-type values from WASM code, this is just a convenience method and simply invokes SimConnect to do the work.
On first use with a new variable name it will set up a mapping of the name to an internally-assigned ID (calling `SimConnect_AddToDataDefinition()`) and cache that mapping.
Then on subsequent invocations on the same variable the mapped ID will be used directly. The mappings are invalidated when disconnecting from the simulator.
</member>
        <member name="M:WASimCommander.Client.WASimClient.setVariable(WASimCommander.Client.VariableRequest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
Set a Variable value by name, with optional named unit type. Although any settable variable type can set this way, it is primarily useful for local (`L`)
variables which can be set via dedicated _Gauge API_ functions (`set_named_variable_value()` and `set_named_variable_typed_value()`). \n\n
Other variables types can also be set this way but such requests are simply converted to a calculator string and
evaluated via the _Gauge API_ `execute_calculator_code()`. Using `WASimClient::executeCalculatorCode()` directly may be more efficient. \n
The following conditions must be observed:
- The variable type in `VariableRequest::variableType` must be "settable" ('A', 'B', 'C', 'H', 'K', 'L', or 'Z'), otherwise an `E_INVALIDARG` result is returned.
- Setting an 'A' type variable this way _requires_ the actual variable name in `VariableRequest::variableName` -- using just an ID returns `E_INVALIDARG`. \n
  (Other settable variable types don't have any associated ID anyway, so this is not an issue.)
- For any variable type _other than_ 'L', a Unit can only be specified as a string (in `VariableRequest::unitName`), not an ID.
  Using only an ID will not cause an error, but the unit will not be included in the generated RPN code. \n
  For 'L' variable types, if both a name and ID are provided, the numeric ID is used insted of the name (this avoids a lookup on the server side).

\param variable See `VariableRequest` documentation for descriptions of the individual fields.
\param value The numeric value to set.
\return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, or `E_FAIL` on general failure (unlikely).
\sa \refwce{CommandId::Set}
</member>
        <member name="M:WASimCommander.Client.WASimClient.getOrCreateLocalVariable(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Double,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDe">
Gets the value of a local variable just like `getLocalVariable()` but will also create the variable on the simulator if it doesn't already exist.
\param variableName Name of the local variable.
\param pfResult Pointer to a double precision variable to hold the result.
\param defaultValue The L var will be created on the simulator if it doesn't exist yet using this initial value (and this same value will be returned in `pfResult`).
\param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic "number" type.
\return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or `E_FAIL` if server returns a Nak response.
\note This method blocks until either the Server responds or the timeout has expired. \sa \refwce{CommandId::GetCreate}, defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.getLocalVariable(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A convenience version of `getVariable(VariableRequest(variableName, false, unitName), pfResult)`. See `getVariable()` and `VariableRequest` for details.
\param variableName Name of the local variable.
\param pfResult Pointer to a double precision variable to hold the result.
\param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic "number" type.
\return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or `E_FAIL` if server returns a Nak response.
\note This method blocks until either the Server responds or the timeout has expired. \sa \refwce{CommandId::Get},  defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.getVariable(WASimCommander.Client.VariableRequest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*)">
\}
\name Variables accessor methods
\{
Get a Variable value by name, with optional named unit type. This is primarily useful for local ('L') variables, SimVars ('A') and token variables ('T') which can be read via dedicated _Gauge API_ functions
(`get_named_variable_value()`/`get_named_variable_typed_value()`, `aircraft_varget()`,  and `lookup_var()` respectively). \n
Other variables types can also be set this way ('C', 'E', 'M', etc) but such requests are simply **converted to a calculator string** and evaluated via the _Gauge API_ `execute_calculator_code()`. \n
Likewise, requesting string-type variables using this method also ends up running a calculator expression on the server side. \n
In both cases, using `WASimClient::executeCalculatorCode()` directly may be more efficient. Also, unlike `executeCalculatorCode()`, this method will not return a string representation of a numeric value.
\param variable See `VariableRequest` documentation for descriptions of the individual fields.
\param pfResult Pointer to a double precision variable to hold the numeric result.
\param psResult Pointer to a string type variable to hold a string-type result. See notes above regarding string types.
\return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or `E_FAIL` if server returns a Nak response.
\note This method blocks until either the Server responds or the timeout has expired.
\sa \refwcc{VariableRequest}, \refwce{CommandId::Get},  defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.executeCalculatorCode(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,&lt;unknown type&gt;,System.Double*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*)">
\}
\name RPN calculator code execution and reusable events
\{
Run a string of MSFS _Gauge API_ calculator code in RPN format, possibly with some kind of result expected.
\param code The text of the code to execute.  See https://docs.flightsimulator.com/html/Additional_Information/Reverse_Polish_Notation.htm
\param resultType Expected result type, or `Enums::CalcResultType::None` (default) if no result is expected. If the type is `Enums::CalcResultType::Formatted` then the server
                  runs the code using `format_calculator_string()` _Gauge API_ function (see @ bottom of RPN docs for formatting options) and the result type is always a string.
                  Otherwise `execute_calculator_code()` is used and any of the result types can be returned (in fact `execute_calculator_code()` always returns any results in all 3 types at once, so even
                  if a numeric result is requested, the string result will also be populated).
\param pfResult A pointer to an initialized variable of `double` to store the result into if `resultType` is `Enums::CalcResultType::Double` or `Enums::CalcResultType::Integer`.
\param psResult A string pointer to store the string result into. The string version is typically populated even for numeric type requests, but definitely for `Enums::CalcResultType::String` or `Enums::CalcResultType::Formatted` type requests.
\return `S_OK` on success, `E_NOT_CONNECTED` if not connected to server; \n
If a result is expected, may also return `E_FAIL` if the server returned Nak response, or `E_TIMEOUT` on general server communication failure.
\note _If_ a result is expected (`resultType` != `Enums::CalcResultType::None`) then this method blocks until either the Server responds or the timeout has expired (see `defaultTimeout()`).
To request calculated results in a non-blocking fashion, use a data request instead.

If you need to execute the same code multiple times, it would be more efficient to save the code as either a data request (for code returning values) or a registered event (for code not returning values).
The advantage is that in those cases the calculator string is pre-compiled to byte code and saved once, then each invocation of the _Gauge API_ calculator functions uses the more efficient byte code version.
(To prevent automatic data updates for data requests, just set the data request period to `Enums::UpdatePeriod::Never` or `Enums::UpdatePeriod::Once` and use the `updateDataRequest()` method to poll for value updates as needed.)
See `saveDataRequest()` and `registerEvent()` respectively for details.
\sa \refwce{CommandId::Exec}, defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.setNetworkConfigurationId(System.Int32)">
SimConnect is used for the network layer. This setting specifies the SimConnect.cfg index to use, or -1 to force a local connection.
Note that this must be called before `connectSimulator()` invocation in order to have any effect. \sa networkConfigurationId().
</member>
        <member name="M:WASimCommander.Client.WASimClient.networkConfigurationId">
SimConnect is used for the network layer. This setting specifies the SimConnect.cfg index to use. The value of -1 forces a local connection.
The initial default setting is read from the `client_conf.ini` file or set to `-1` if no config file was found. \sa setNetworkConfigurationId().
</member>
        <member name="M:WASimCommander.Client.WASimClient.defaultTimeout">
Get the current default server response timeout value, which is used in all network requests.
The initial default setting is read from the `client_conf.ini` file or set to 1000ms if no config file was found. \sa setDefaultTimeout().
</member>
        <member name="M:WASimCommander.Client.WASimClient.disconnectServer">
Disconnect from the WASimCommander server. This does _not_ close the Simulator network connection (use \c disconnectSimulator() to do that or both at once).
</member>
        <member name="M:WASimCommander.Client.WASimClient.connectServer(System.UInt32)">
Connect to WASimCommander server.
This will implicitly call \c connectSimulator() first if it hasn't already been done, using the default network configuration setting.
\param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.
\return `S_OK` (0) - Success.\n
 `E_FAIL` (0x80004005) - General failure (most likely simulator is not running).\n
 `E_TIMEOUT` (0x800705B4) - Connection attempt timed out (simulator/network issue or WASimCommander WASM module is not installed/running).\n
 `E_INVALIDARG` (0x80070057) - The Client ID set in constructor is invalid (zero) or the SimConnect.cfg file did not contain the default config index.
\note This method blocks until either the Server responds or the timeout has expired. \sa defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.pingServer(System.UInt32)">
Check if WASimCommander Server exists (Simulator running, the WASIM module is installed and working). Returns server version number, or zero if server did not respond.\n
This will implicitly call `connectSimulator()` first if it hasn't already been done, using the default network configuration settings. Zero will be returned if the connection could not be established.
\param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.
\return Server version number, or zero (`0`) if server (or simulator) didn't respond within the timeout period.
\note This method blocks until either the Server responds or the timeout has expired. \sa defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.disconnectSimulator">
Shut down all network connections (and disconnect WASimCommander server if connected).
After calling this method, one must call `connectSimulator()`/`connectServer()`/`pingServer()` again before any other commands.
</member>
        <member name="M:WASimCommander.Client.WASimClient.connectSimulator(System.Int32,System.UInt32)">
Initialize the simulator network link and set up minimum necessary for WASimCommander server ping or connection. This overload allows specifying a SimConnect configuration ID and optional timeout value.
\param networkConfigId SimConnect is used for the network layer. Specify the SimConnect.cfg index to use, or -1 (default) to force a local connection.
\param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.
\return `S_OK` (0) - Success;\n
 `E_FAIL` (0x80004005) - General failure (most likely simulator is not running);\n
 `E_TIMEOUT` (0x800705B4) - Connection attempt timed out (simulator/network issue);\n
 `E_INVALIDARG` (0x80070057) - The Client ID set in constructor is invalid (zero) or the SimConnect.cfg file did not contain the config index requested in the `simConnectConfigId` parameter;
\note This method blocks until either the Simulator responds or the timeout has expired. \sa connectSimulator(), defaultTimeout(), setDefaultTimeout()
</member>
        <member name="M:WASimCommander.Client.WASimClient.connectSimulator(System.UInt32)">
Initialize the simulator network link and set up minimum necessary for WASimCommander server ping or connection. Uses default network SimConnect configuration ID.
\param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.
\return `S_OK` (0) - Success;\n
 `E_FAIL` (0x80004005) - General failure (most likely simulator is not running);\n
 `E_TIMEOUT` (0x800705B4) - Connection attempt timed out (simulator/network issue);\n
 `E_INVALIDARG` (0x80070057) - The Client ID set in constructor is invalid (zero) or the SimConnect.cfg file did not contain the default config index (see `networkConfigurationId()` ) ;
\note This method blocks until either the Simulator responds or the timeout has expired.
\sa defaultTimeout(), setDefaultTimeout(), networkConfigurationId() setNetworkConfigurationId(), connectSimulator(int, uint32_t)
</member>
        <member name="M:WASimCommander.Client.WASimClient.status">
\name Network actions, status, and settings
\{
</member>
        <member name="M:WASimCommander.Client.WASimClient.Dispose">
Any open network connections are automatically closed upon destruction, though it is better to close them yourself before deleting the client.
</member>
        <member name="M:WASimCommander.Client.WASimClient.#ctor(System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Instantiate the client with a unique ID and optional configuration file path.
\param clientId This ID must not be shared with any other Client accessing the Server.
  The ID is also used as the client name by converting it to a 8-character hexadecimal string. For example 3235839725 = "C0DEFEED". Get creative.
  The client name is used as a key component of data exchange with the simulator engine.
  The ID cannot be zero, and server connections will fail if it is. It can also be set/changed after class creation using the `setClientId()` method, but before connecting to the server.
\param configFile Optionally provide the path to a configuration file for reading initial startup settings. By default the client will look for a `client_conf.ini` file in the current working directory.
  The parameter value may include the file name (with extension), or be only a file system path, in which case the default file name of "client_conf.ini" will be appended.
</member>
        <member name="T:WASimCommander.Client.WASimClient">
WASimCommander Client implementation. Handles all aspects of communication with the WASimCommander Server WASM module.
</member>
        <member name="M:WASimCommander.Client.RegisteredEvent.#ctor(System.UInt32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 If the custom event name contains a period (`.`) then it is used as-is. Otherwise "WASimCommander.[client_name]." will be prepended to the name.
 \note The event name **cannot be changed** after the initial registration (it is essentially equivalent to the `eventId`). When updating an existing event on the server, it is
 not necessary to include the name again, only the `eventId` is required (and the code to execute, of course). Maximum length for the name string is the value of `WASimCommander::STRSZ_ENAME`.
Default implicit constructor.
</member>
        <member name="T:WASimCommander.Client.RegisteredEvent">
Structure to hold data for registered (reusable) calculator events. Used to submit events with `WASimClient::registerEvent()`.

WASimClient also holds a list of all registered events which have been added using `WASimClient::registerEvent()`. These
requests are available for reference using `WASimClient::registeredEvent()` and `WASimClient::registeredEvents()` methods.
\sa WASimClient::registerEvent(), WASimCommander::CommandId::Register
</member>
        <member name="M:WASimCommander.Client.VariableRequest.#ctor(System.Int32)">
Construct a variable request for a Local variable ('L') with the given numeric ID.
</member>
        <member name="M:WASimCommander.Client.VariableRequest.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct a variable request for a Local variable ('L') with the given name. `createVariable` will create the L var on the simulator if it doesn't exist yet
(for "Get" as well as "Set" commands). An optional unit name can also be provided.
</member>
        <member name="M:WASimCommander.Client.VariableRequest.#ctor(System.Int32,System.Int32,System.Byte)">
Construct a variable request for a Simulator Variable ('A') using numeric variable and unit IDs, with optional index parameter.
</member>
        <member name="M:WASimCommander.Client.VariableRequest.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte)">
Construct a variable request for a Simulator Variable (SimVar) with given name, unit, and optional index parameter.
</member>
        <member name="M:WASimCommander.Client.VariableRequest.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32,System.Int32,System.Byte)">
Construct a variable request using numeric variable and (optionally) unit IDs, and optional SimVar index.
</member>
        <member name="M:WASimCommander.Client.VariableRequest.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.Compiler">
Default constructor, with optional parameters for variable type, name, unit name, SimVar index and `createLVar` flag.
</member>
        <member name="F:WASimCommander.Client.VariableRequest.variableId">
 Otherwise, for 'L' vars the default units are used (_Gauge API_ `(get | set)_named_variable_value()`) and for getting SimVars the behavior is undefined (-1 is passed to `aircraft_varget()` as the unit ID).
 For the other variable types which use units ('C', 'E', or when setting 'A'), this string will simply be included in the produced calculator code (eg. `(E:SIMULATION TIME,seconds)` or `50 (&gt;A:COCKPIT CAMERA ZOOM,percent)`).
 The unit name is ignored for all other variable types, and the `unitId` field is preferred if it is greater than -1.
</member>
        <member name="T:WASimCommander.Client.VariableRequest">
Structure for using with `WASimClient::getVariable()` and `WASimClient::setVariable()` to specify information about the variable to set or get. Variables and Units can be specified by name or by numeric ID.
Only some variable types have an associated numeric ID ('A', 'L', 'T' types) and only some variable types accept a Unit specifier ('A', 'C', 'E', 'L' types). Using numeric IDs, if already known, is more efficient
on the server side since it saves the lookup step.
</member>
        <member name="T:WASimCommander.Client.ListResult">
Structure for delivering list results, eg. of local variables sent from Server.
\sa WASimClient::list(), listResultsCallback_t, WASimCommander::LookupItemType, WASimCommander::CommandId::List command.
</member>
        <member name="T:WASimCommander.Client.ClientEvent">
Client Event data, delivered via callback. \sa WASimClient::setClientEventCallback(), ClientEventType, ClientStatus
</member>
        <member name="T:WASimCommander.Client.LogSource">
\}
Log entry source, Client or Server. \sa WASimClient::logCallback_t
</member>
        <member name="T:WASimCommander.Client.ClientEventType">
\}
Client event type enumeration. \sa ClientEvent, ClientStatus, WASimClient::setClientEventCallback()
</member>
        <member name="T:WASimCommander.Client.ClientStatus">
Client status flags. \sa WASimClient::status()
</member>
        <member name="M:WASimCommander.LogRecord.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,WASimCommander.LogRecord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
`ostream` operator for logging purposes
</member>
        <member name="M:WASimCommander.LogRecord.#ctor(&lt;unknown type&gt;!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,std.chrono.time_point&lt;std.chrono.system_clock,std.chrono.duration&lt;System.Int64,std.ratio&lt;0x01,0x0989680&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Default constructor with all parameters optional.
</member>
        <member name="T:WASimCommander.LogRecord">
Log record structure. \sa WASimCommander:CommandId::Log command.
</member>
        <member name="M:WASimCommander.KeyEvent.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,WASimCommander.KeyEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
`ostream` operator for logging purposes
</member>
        <member name="M:WASimCommander.KeyEvent.#ctor(System.UInt32,std.initializer_list&lt;System.UInt32&gt;,System.UInt32)">
Default constructor with all parameters optional. The `values` initializer list may contain up to 5 members (any additional are ignored).
</member>
        <member name="T:WASimCommander.KeyEvent">
Data structure for sending Key Events to the sim with up to 5 event values. Events are specified using numeric MSFS Event IDs (names can be resolved to IDs via `Lookup` command).
This supports the new functionality in MSFS SU10 with `trigger_key_event_EX1()` Gauge API function (similar to `SimConnect_TransmitClientEvent_EX1()`).
The server will respond with an Ack/Nak for a `SendKey` command, echoing the given `token`. For events with zero or one value, the `SendKey` command can be used instead.
\since v1.1.0  \sa Enums::CommandId::SendKey, Enums::CommandId::Lookup
</member>
        <member name="M:WASimCommander.DataRequest.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,WASimCommander.DataRequest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
`ostream` operator for logging purposes
</member>
        <member name="M:WASimCommander.DataRequest.#ctor(System.UInt32,&lt;unknown type&gt;,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,&lt;unknown type&gt;,System.UInt32,System.Single)">
Constructs a calculator code request (`requestType = RequestType::Calculated`) with optional update period, interval, and epsilon values. \n
This overload, w/out a `valueSize` argument automatically determines the size based on the `resultType` argument:
- `CalcResultType::Double`  = `WASimCommander::DATA_TYPE_DOUBLE`
- `CalcResultType::Integer` = `WASimCommander::DATA_TYPE_INT32`
- `CalcResultType::String`  = 256
</member>
        <member name="M:WASimCommander.DataRequest.#ctor(System.UInt32,&lt;unknown type&gt;,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,&lt;unknown type&gt;,System.UInt32,System.Single)">
Constructs a calculator code request (`requestType = RequestType::Calculated`) with optional update period, interval, and epsilon values.
</member>
        <member name="M:WASimCommander.DataRequest.#ctor(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Byte,System.UInt32,&lt;unknown type&gt;,System.UInt32,System.Single)">
Constructs a request for a named Simulator Variable (`requestType = RequestType::Named` and `varTypePrefix = 'A'`) with optional update period, interval, and epsilon values.
</member>
        <member name="M:WASimCommander.DataRequest.#ctor(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,&lt;unknown type&gt;,System.UInt32,System.Single)">
Constructs a request for a named variable (`requestType = RequestType::Named`) with optional update period, interval, and epsilon values.
</member>
        <member name="M:WASimCommander.DataRequest.#ctor(System.UInt32,System.UInt32,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Single,System.Byte,System.Byte)">
Constructor with required request ID, all other parameters optional. See member documentation for explanation of the homonymous parameters.
</member>
        <member name="F:WASimCommander.DataRequest.period">
 Zero means to check at every `period`, `1` means every other `period`, etc.
</member>
        <member name="T:WASimCommander.DataRequest">
Structure for variable value subscription requests. \sa WASimCommander:CommandId::Subscribe command.
</member>
        <member name="M:WASimCommander.Command.op_LeftShift(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
`ostream` operator for logging purposes
</member>
        <member name="M:WASimCommander.Command.#ctor(&lt;unknown type&gt;,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32)">
Default constructor with all parameters optional.
</member>
        <member name="T:WASimCommander.Command">
Command data structure. The member contents depend on the command type as described in each command type of the `Enums::CommandId` enum documentation. \sa Enums::CommandId enum
</member>
        <member name="M:WASimCommander.setCharArrayValue(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
\}
\private
</member>
        <member name="T:WASimCommander.Enums.LogFacility">
\}
Logging destination type. \sa CommandId::Log command.
</member>
        <member name="T:WASimCommander.Enums.LogLevel">
\}
Logging levels. \sa LogRecord struct, CommandId::Log command.
</member>
        <member name="T:WASimCommander.Enums.LookupItemType">
\}
Types of things to look up or list. \sa Enums::CommandId::List, Enums::CommandId::Lookup commands
</member>
        <member name="T:WASimCommander.Enums.UpdatePeriod">
\}
How often to check for updated request values. \sa DataRequest struct.
</member>
        <member name="T:WASimCommander.Enums.CalcResultType">
\}
The type of result that calculator code is expected to produce. \sa DataRequest struct, Enums::CommandId::Exec command.
</member>
        <member name="T:WASimCommander.Enums.RequestType">
\}
Types of things to request or set. \sa DataRequest struct.
</member>
        <member name="T:WASimCommander.Enums.CommandId">
Commands for client-server interaction. Both sides can send commands via dedicated channels by writing a \refwc{Command} data structure.
The fields `uData`, `sData` and `fData` referenced below refer to \refwc{Command::uData}, \refwc{Command::sData} and \refwc{Command::fData} respectively.
\sa Command struct.
</member>
        <member name="F:Log">
 "The send_key_event function transmits a WM_COMMAND application event. This function transmits a message with the following syntax: `PostMessage(hwndMain, WM_COMMAND, event_id, (LPARAM) value);`"\n\n
 In practice this means you can send a KEY Event ID directly to the simulator, bypassing SimConnect event name mappings or calculator code evaluation. The event IDs can be found in the MSFS SDK's `MSFS/Legacy/gauges.h` header file as `KEY_*` macros,
 and are also available via the `Lookup` command. If this command is sent with `uData` == 0 and `sData` contains a string, a `LookupItemType::KeyEventId` lookup will be performed on the Key Event name first and the resulting ID (if any) used.\n\n
 Custom event IDs (registered by gauges or other modules) can also be triggered this way. There may be other uses for this command... TBD.
</member>
        <member name="F:SendKey">
 manner for subscriptions, by writing the new value to the related client data area. Note also that this command will force an update of the data, without comparing the result to any (potentially) cached value from previous lookup.
</member>
        <member name="F:Update">
 This command ID is also used as an `Ack/Nak` response to new Data Request records being processed. The client must write a `DataRequest` struct to the shared data area and the server should respond with this command to indicate success/failure.
</member>
        <member name="F:Transmit">
 If the custom event name contains a period (`.`) then it is used as-is. Otherwise "WASimCommander.[client_name]." will be prepended to the given name.\n
 Use with `SimConnect_MapClientEventToSimEvent(id, "event_name")` and `SimConnect_TransmitClientEvent()`, or the `Transmit` command (below).\n
 To change the calculator string used for an event, re-send this command with the same event ID and a new string to use. The event name cannot be modified after creation.\n
 To remove a registered event, send this command with the event ID to delete and a blank `sData`.
</member>
        <member name="F:Register">
 (Due to the way the _Gauge API_ calculator function works, a string result is typically also returned even when only a numeric result is requested.)\n\n
 In case of failure a `Nak` is returned with possible error message in `sData`. Note however that the _Gauge API_ functions often happily return a "success" status even when the actual thing you're trying to do fails. The only feedback
 in this case appears to be the MSFS Console window available from "Dev Tools," which will (usually) log any actual errors.
</member>
        <member name="F:Exec">
 **Creating variables only works with `L` (local) types.** Since v1.2, for all other types this command will be handled the same as `Get`. Previous versions would return a `Nak`.
</member>
        <member name="F:SetCreate">
 `sData` is the variable name or numeric ID (for local vars only), optionally followed by comma (`,`) and unit name (or numeric unit ID for local vars) (**no spaces**). The value to set is passed in `fData` member.\n
 For example, a SimVar: ```uData = 'A'; sData = "PROP RPM:2,rpm"; fData = 2200;```\n
 Other variables types can also be set this way ('A', 'H", 'K', etc) but such requests are simply converted to a calculator string and processed as an `Exec` type command (using an `Exec` command directly may be slightly more efficient).
</member>
        <member name="F:Set">
 \n **Since v1.2:** If a variable is created, the value provided in `fData` will be used as the initial value of the variable, and will be returned as the result
(essentially providing a default value in this case). Previous versions would _not_ set a value (or unit type) on the variable after creating it and would return the default of `0.0`. \n
 **Creating variables only works with `L` (local) types.** Since v1.2, for all other types this command will be handled the same as `Get`. Previous versions would return a `Nak`.
</member>
        <member name="F:GetCreate">
 `sData` is the variable name or numeric ID, optionally followed by comma (`,`) and unit name or numeric ID (**no spaces**). For indexed SimVars, include the index after the variable name, separated by a colon (`:`).\n
 For example, a SimVar: ```uData = 'A'; sData = "PROP BETA:2,degrees";``` \n
 Other variables types can also be requested ('B', 'E', 'M', etc) but such requests are simply converted to a calculator string and processed as an `Exec` type command (using an `Exec` command directly may be more efficient).\n
 Result is returned with the `Ack` response in `fData` as a double-precision value. In case of failure a `Nak` is returned with possible error message in `sData`.
</member>
        <member name="F:Get">
 `Ack` is returned on success with the ID of the variable/unit in the `fData` member (as an `INT32`) and the original requested string name echoed back in `sData`. In case of lookup failure, a `Nak` response is returned with possible reason in `sData`.
</member>
        <member name="F:Lookup">
 List is returned as a series of `List` type response commands with `sData` as var name and `uData` is var ID, followed by an `Ack` at the end. A `Nak` response is returned if the item type cannot be listed for any reason.
</member>
        <!-- Discarding badly formed XML document comment for member 'F:WASimCommander.DataRequest.interval'. -->
        <!-- Discarding badly formed XML document comment for member 'T:WASimCommander.Client.DataRequestRecord'. -->
        <!-- Discarding badly formed XML document comment for member 'F:WASimCommander.Client.RegisteredEvent.name'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setDefaultTimeout(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setSimVarVariable(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setSimVarVariable(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setSimVarVariable(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.removeCustomKeyEvent(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setClientEventCallback(std.function<(WASimCommander.Client.ClientEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(WASimCommander.Client.ClientEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&)>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setListResultsCallback(std.function<(WASimCommander.Client.ListResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(WASimCommander.Client.ListResult!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&)>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setDataCallback(std.function<(WASimCommander.Client.DataRequestRecord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(WASimCommander.Client.DataRequestRecord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&)>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setLogCallback(std.function<(WASimCommander.LogRecord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,<unknown type>)(WASimCommander.LogRecord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&,<unknown type>)>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setCommandResultCallback(std.function<(WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&)>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.Client.WASimClient.setResponseCallback(std.function<(WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(WASimCommander.Command!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&)>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.setVariable(WASimCommander.CLI.Structs.VariableRequest,System.Double!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.setVariable(WASimCommander.CLI.Structs.VariableRequest,System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.setSimVarVariable(System.String,System.String,System.Double!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.setSimVarVariable(System.String,System.Byte,System.String,System.Double!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.setSimVarVariable(System.String,System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.setSimVarVariable(System.String,System.Byte,System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.sendKeyEvent(System.String,System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32},System.Nullable`1{System.UInt32})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:WASimCommander.CLI.Client.WASimClient.removeCustomKeyEvent(System.String)'. -->
    </members>
</doc>